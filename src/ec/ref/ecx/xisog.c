#include "isog.h"
#include "ec.h"
#include <assert.h>

// -------------------------------------------------------------------------
// -------------------------------------------------------------------------

// Degree-2 isogeny with kernel generated by P != (0 ,0)
// Outputs the curve coefficient in the form A24=(A+2C:4C)
void
xisog_2(ec_kps2_t *kps, ec_point_t *B, const ec_point_t P)
{
    fp2_sqr(&B->x, &P.x);
    fp2_sqr(&B->z, &P.z);
    fp2_sub(&B->x, &B->z, &B->x);
    fp2_add(&kps->K.x, &P.x, &P.z);
    fp2_sub(&kps->K.z, &P.x, &P.z);
}

// TODO we may be more efficient than that ?
void
xisog_2_singular(ec_kps2_t *kps, ec_point_t *B24, ec_point_t A24)
{
    fp2_t t0, four;
    fp2_set_small(&four, 4);
    fp2_add(&t0, &A24.x, &A24.x);
    fp2_sub(&t0, &t0, &A24.z);
    fp2_add(&t0, &t0, &t0);
    fp2_inv(&A24.z);
    fp2_mul(&t0, &t0, &A24.z);
    fp2_copy(&kps->K.x, &t0);
    fp2_add(&B24->x, &t0, &t0);
    fp2_sqr(&t0, &t0);
    fp2_sub(&t0, &t0, &four);
    fp2_sqrt(&t0);
    fp2_neg(&kps->K.z, &t0);
    fp2_add(&B24->z, &t0, &t0);
    fp2_add(&B24->x, &B24->x, &B24->z);
    fp2_add(&B24->z, &B24->z, &B24->z);
}

// Degree-4 isogeny with kernel generated by P such that [2]P != (0 ,0)
// Outputs the curve coefficient in the form A24=(A+2C:4C)
void
xisog_4(ec_kps4_t *kps, ec_point_t *B, const ec_point_t P)
{
    ec_point_t *K = kps->K;

    fp2_sqr(&K[0].x, &P.x);
    fp2_sqr(&K[0].z, &P.z);
    fp2_add(&K[1].x, &K[0].z, &K[0].x);
    fp2_sub(&K[1].z, &K[0].z, &K[0].x);
    fp2_mul(&B->x, &K[1].x, &K[1].z);
    fp2_sqr(&B->z, &K[0].z);

    // Constants for xeval_4
    fp2_add(&K[2].x, &P.x, &P.z);
    fp2_sub(&K[1].x, &P.x, &P.z);
    fp2_add(&K[0].x, &K[0].z, &K[0].z);
    fp2_add(&K[0].x, &K[0].x, &K[0].x);
}

// Degree-4 isogeny with kernel generated by P such that [2]P = (0 ,0)
void
xisog_4_singular(ec_kps4_t *kps, ec_point_t *B24, const ec_point_t P, ec_point_t A24)
{
    ec_point_t *K = kps->K;
    fp2_copy(&K[0].z, &A24.z);
    // If Px == Pz then
    // K[0].x = A24.x
    // K[1].x = A24.x - A24.z
    // B24.z  = -K[1].x
    // Otherwise
    // K[1].x = A24.x
    // K[0].x = A24.x - A24.z
    // B24.z  = K[1].x

    // Check whether P.x == P.z
    uint32_t xz_equal = fp2_is_equal(&P.x, &P.z);

    // Compute K[i].x as above
    fp2_copy(&K[1].x, &A24.x);
    fp2_sub(&K[0].x, &A24.x, &A24.z);
    fp2_cswap(&K[0].x, &K[1].x, xz_equal);

    // Compute B24
    fp2_t tmp;
    fp2_neg(&tmp, &K[1].x);
    fp2_select(&B24->z, &K[1].x, &tmp, xz_equal);
    fp2_copy(&B24->x, &K[0].z);
}

// xISOG procedure, which is a hybrid between Montgomery and Twisted Edwards
// This tradition fomulae corresponds with the Twisted Edwards formulae but
// mapping the output into Montgomery form
void
xisog_t(ec_point_t *B, uint64_t const i, ec_point_t const A)
{
    int j;
    int d = ((int)TORSION_ODD_PRIMES[i] - 1) / 2; // Here, l = 2d + 1

    fp2_t By, Bz, constant_d_edwards, tmp_a, tmp_d;

    fp2_copy(&By, &K[0].x);
    fp2_copy(&Bz, &K[0].z);

    for (j = 1; j < d; j++) {
        fp2_mul(&By, &By, &K[j].x);
        fp2_mul(&Bz, &Bz, &K[j].z);
    };

    // Mapping Montgomery curve coefficients into Twisted Edwards form
    fp2_sub(&constant_d_edwards, &A.x, &A.z);
    fp2_copy(&tmp_a, &A.x);
    fp2_copy(&tmp_d, &constant_d_edwards);

    // left-to-right method for computing a^l and d^l
    for (j = 1; j < (int)p_plus_minus_bitlength[i]; j++) {
        fp2_sqr(&tmp_a, &tmp_a);
        fp2_sqr(&tmp_d, &tmp_d);
        if ((((int)TORSION_ODD_PRIMES[i] >> ((int)p_plus_minus_bitlength[i] - j - 1)) & 1) != 0) {
            fp2_mul(&tmp_a, &tmp_a, &A.x);
            fp2_mul(&tmp_d, &tmp_d, &constant_d_edwards);
        };
    };

    // raising to 8-th power
    for (j = 0; j < 3; j++) {
        fp2_sqr(&By, &By);
        fp2_sqr(&Bz, &Bz);
    };

    // Mapping Twisted Edwards curve coefficients into Montgomery form
    fp2_mul(&(B->x), &tmp_a, &Bz);
    fp2_mul(&(B->z), &tmp_d, &By);
    fp2_sub(&(B->z), &(B->x), &(B->z));
}

// Degree-3 isogeny with kernel generated by P
// Must be called after kps_3(P).
void xisog_3(ec_point_t* B, const ec_point_t K)
{
	fp2_t t0, t1, t2, t3, t4;
	fp2_sqr(&t0, &K.x);
	fp2_sqr(&t1, &K.z);
	fp2_add(&t2, &t0, &t1);
	fp2_add(&t3, &K.x, &K.z);
	fp2_sqr(&t3, &t3);
	fp2_sub(&t3, &t3, &t2);
	fp2_add(&t2, &t1, &t3);
	fp2_add(&t3, &t3, &t0);
	fp2_add(&t4, &t3, &t0);
	fp2_add(&t4, &t4, &t4);
	fp2_add(&t4, &t1, &t4);
	fp2_mul(&B->z, &t2, &t4); // D
	fp2_add(&t4, &t1, &t2);
	fp2_add(&t4, &t4, &t4);
	fp2_add(&t4, &t0, &t4);
	fp2_mul(&B->x, &t3, &t4); // C
	fp2_sub(&B->z, &B->x, &B->z); // C - D
}